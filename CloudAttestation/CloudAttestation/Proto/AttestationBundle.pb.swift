// Copyright © 2025 Apple Inc. All Rights Reserved.

// APPLE INC.
// PRIVATE CLOUD COMPUTE SOURCE CODE INTERNAL USE LICENSE AGREEMENT
// PLEASE READ THE FOLLOWING PRIVATE CLOUD COMPUTE SOURCE CODE INTERNAL USE LICENSE AGREEMENT (“AGREEMENT”) CAREFULLY BEFORE DOWNLOADING OR USING THE APPLE SOFTWARE ACCOMPANYING THIS AGREEMENT(AS DEFINED BELOW). BY DOWNLOADING OR USING THE APPLE SOFTWARE, YOU ARE AGREEING TO BE BOUND BY THE TERMS OF THIS AGREEMENT. IF YOU DO NOT AGREE TO THE TERMS OF THIS AGREEMENT, DO NOT DOWNLOAD OR USE THE APPLE SOFTWARE. THESE TERMS AND CONDITIONS CONSTITUTE A LEGAL AGREEMENT BETWEEN YOU AND APPLE.
// IMPORTANT NOTE: BY DOWNLOADING OR USING THE APPLE SOFTWARE, YOU ARE AGREEING ON YOUR OWN BEHALF AND/OR ON BEHALF OF YOUR COMPANY OR ORGANIZATION TO THE TERMS OF THIS AGREEMENT.
// 1. As used in this Agreement, the term “Apple Software” collectively means and includes all of the Apple Private Cloud Compute materials provided by Apple here, including but not limited to the Apple Private Cloud Compute software, tools, data, files, frameworks, libraries, documentation, logs and other Apple-created materials. In consideration for your agreement to abide by the following terms, conditioned upon your compliance with these terms and subject to these terms, Apple grants you, for a period of ninety (90) days from the date you download the Apple Software, a limited, non-exclusive, non-sublicensable license under Apple’s copyrights in the Apple Software to download, install, compile and run the Apple Software internally within your organization only on a single Apple-branded computer you own or control, for the sole purpose of verifying the security and privacy characteristics of Apple Private Cloud Compute. This Agreement does not allow the Apple Software to exist on more than one Apple-branded computer at a time, and you may not distribute or make the Apple Software available over a network where it could be used by multiple devices at the same time. You may not, directly or indirectly, redistribute the Apple Software or any portions thereof. The Apple Software is only licensed and intended for use as expressly stated above and may not be used for other purposes or in other contexts without Apple's prior written permission. Except as expressly stated in this notice, no other rights or licenses, express or implied, are granted by Apple herein.
// 2. The Apple Software is provided by Apple on an "AS IS" basis. APPLE MAKES NO WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN COMBINATION WITH YOUR PRODUCTS, SYSTEMS, OR SERVICES. APPLE DOES NOT WARRANT THAT THE APPLE SOFTWARE WILL MEET YOUR REQUIREMENTS, THAT THE OPERATION OF THE APPLE SOFTWARE WILL BE UNINTERRUPTED OR ERROR-FREE, THAT DEFECTS IN THE APPLE SOFTWARE WILL BE CORRECTED, OR THAT THE APPLE SOFTWARE WILL BE COMPATIBLE WITH FUTURE APPLE PRODUCTS, SOFTWARE OR SERVICES. NO ORAL OR WRITTEN INFORMATION OR ADVICE GIVEN BY APPLE OR AN APPLE AUTHORIZED REPRESENTATIVE WILL CREATE A WARRANTY.
// 3. IN NO EVENT SHALL APPLE BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT, INCIDENTAL OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, COMPILATION OR OPERATION OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// 4. This Agreement is effective until terminated. Your rights under this Agreement will terminate automatically without notice from Apple if you fail to comply with any term(s) of this Agreement. Upon termination, you agree to cease all use of the Apple Software and destroy all copies, full or partial, of the Apple Software. This Agreement constitutes the entire understanding of the parties with respect to the subject matter contained herein, and supersedes all prior negotiations, representations, or understandings, written or oral. This Agreement will be governed and construed in accordance with the laws of the State of California, without regard to its choice of law rules.
// You may report security issues about Apple products to product-security@apple.com, as described here: https://www.apple.com/support/security/. Non-security bugs and enhancement requests can be made via https://bugreport.apple.com as described here: https://developer.apple.com/bug-reporting/
// EA1937
// 10/02/2024

// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: AttestationBundle.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import InternalSwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: InternalSwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: InternalSwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Proto_HashAlg: InternalSwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unknown // = 0
  case sha256 // = 1
  case sha384 // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .sha256
    case 2: self = .sha384
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .sha256: return 1
    case .sha384: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Proto_HashAlg] = [
    .unknown,
    .sha256,
    .sha384,
  ]

}

public struct Proto_AttestationBundle: @unchecked Sendable {
  // InternalSwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// DER encoded SEP attestation blob.
  public var sepAttestation: Data {
    get {return _storage._sepAttestation}
    set {_uniqueStorage()._sepAttestation = newValue}
  }

  /// Image4 Manifest DER blob.
  public var apTicket: Data {
    get {return _storage._apTicket}
    set {_uniqueStorage()._apTicket = newValue}
  }

  public var sealedHashes: Proto_SealedHashLedger {
    get {return _storage._sealedHashes ?? Proto_SealedHashLedger()}
    set {_uniqueStorage()._sealedHashes = newValue}
  }
  /// Returns true if `sealedHashes` has been explicitly set.
  public var hasSealedHashes: Bool {return _storage._sealedHashes != nil}
  /// Clears the value of `sealedHashes`. Subsequent reads from it will return its default value.
  public mutating func clearSealedHashes() {_uniqueStorage()._sealedHashes = nil}

  /// DCIK certificate for Private Cloud Compute
  public var provisioningCertificateChain: [Data] {
    get {return _storage._provisioningCertificateChain}
    set {_uniqueStorage()._provisioningCertificateChain = newValue}
  }

  /// Use-case specific data. sha256 digest of this is included in the nonce
  public var appData: Data {
    get {return _storage._appData}
    set {_uniqueStorage()._appData = newValue}
  }

  /// Unix timestamp of the key's expiration, as hinted by the attested device
  public var keyExpiration: InternalSwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._keyExpiration ?? InternalSwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._keyExpiration = newValue}
  }
  /// Returns true if `keyExpiration` has been explicitly set.
  public var hasKeyExpiration: Bool {return _storage._keyExpiration != nil}
  /// Clears the value of `keyExpiration`. Subsequent reads from it will return its default value.
  public mutating func clearKeyExpiration() {_uniqueStorage()._keyExpiration = nil}

  public var transparencyProofs: Proto_TransparencyProofs {
    get {return _storage._transparencyProofs ?? Proto_TransparencyProofs()}
    set {_uniqueStorage()._transparencyProofs = newValue}
  }
  /// Returns true if `transparencyProofs` has been explicitly set.
  public var hasTransparencyProofs: Bool {return _storage._transparencyProofs != nil}
  /// Clears the value of `transparencyProofs`. Subsequent reads from it will return its default value.
  public mutating func clearTransparencyProofs() {_uniqueStorage()._transparencyProofs = nil}

  public var unknownFields = InternalSwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Proto_AppData: Sendable {
  // InternalSwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 1
  public var version: UInt32 = 0

  /// com.apple.PrivateCloudCompute
  public var domain: String = String()

  /// Proxy Node vs Compute Node
  public var name: String = String()

  /// Empty for Compute Node, PrivateCloudCompute_ProxyNodeMetadata for Proxy Node
  public var metadata: InternalSwiftProtobuf.Google_Protobuf_Any {
    get {return _metadata ?? InternalSwiftProtobuf.Google_Protobuf_Any()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var unknownFields = InternalSwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: InternalSwiftProtobuf.Google_Protobuf_Any? = nil
}

public struct Proto_SealedHashLedger: Sendable {
  // InternalSwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var slots: Dictionary<String,Proto_SealedHash> = [:]

  public var unknownFields = InternalSwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_SealedHash: Sendable {
  // InternalSwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hashAlg: Proto_HashAlg = .unknown

  public var entries: [Proto_SealedHash.Entry] = []

  public var unknownFields = InternalSwiftProtobuf.UnknownStorage()

  public struct Entry: @unchecked Sendable {
    // InternalSwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Flags set for the sealed hash update. Uses int32 since Flags can be Bitwise OR'd together.
    public var flags: Int32 = 0

    /// The actual bytes (up to 48) sent to AppleKeyStore to set or ratchet into a Software Sealed Hash Register. Despite the name, it isn't necessarily a digest.
    public var digest: Data = Data()

    /// A tagged union of different payloads that are written to a Software Sealed Hash Register.
    /// Each payload should have enough information in of itself to reconstruct the above `digest` value.
    public var info: Proto_SealedHash.Entry.OneOf_Info? = nil

    /// Generic unknown bytes
    public var generic: Data {
      get {
        if case .generic(let v)? = info {return v}
        return Data()
      }
      set {info = .generic(newValue)}
    }

    /// Information over a cryptex that result to `digest` when hashed canonically using `alg`
    public var cryptex: Proto_Cryptex {
      get {
        if case .cryptex(let v)? = info {return v}
        return Proto_Cryptex()
      }
      set {info = .cryptex(newValue)}
    }

    /// A libCryptex defined magic value that serves as and END marker for a register. Typically should have FLAG_RATCHET_LOCKED
    public var cryptexSalt: Proto_Cryptex.Salt {
      get {
        if case .cryptexSalt(let v)? = info {return v}
        return Proto_Cryptex.Salt()
      }
      set {info = .cryptexSalt(newValue)}
    }

    /// A SecureConfig Entry
    public var secureConfig: Proto_SecureConfig {
      get {
        if case .secureConfig(let v)? = info {return v}
        return Proto_SecureConfig()
      }
      set {info = .secureConfig(newValue)}
    }

    public var metadata: Dictionary<String,Data> = [:]

    public var unknownFields = InternalSwiftProtobuf.UnknownStorage()

    /// A tagged union of different payloads that are written to a Software Sealed Hash Register.
    /// Each payload should have enough information in of itself to reconstruct the above `digest` value.
    public enum OneOf_Info: Equatable, @unchecked Sendable {
      /// Generic unknown bytes
      case generic(Data)
      /// Information over a cryptex that result to `digest` when hashed canonically using `alg`
      case cryptex(Proto_Cryptex)
      /// A libCryptex defined magic value that serves as and END marker for a register. Typically should have FLAG_RATCHET_LOCKED
      case cryptexSalt(Proto_Cryptex.Salt)
      /// A SecureConfig Entry
      case secureConfig(Proto_SecureConfig)

    }

    public enum Flags: InternalSwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int
      case flagNone // = 0
      case flagRatchet // = 2
      case flagRatchetLock // = 4
      case UNRECOGNIZED(Int)

      public init() {
        self = .flagNone
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .flagNone
        case 2: self = .flagRatchet
        case 4: self = .flagRatchetLock
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .flagNone: return 0
        case .flagRatchet: return 2
        case .flagRatchetLock: return 4
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Proto_SealedHash.Entry.Flags] = [
        .flagNone,
        .flagRatchet,
        .flagRatchetLock,
      ]

    }

    public init() {}
  }

  public init() {}
}

public struct Proto_Cryptex: @unchecked Sendable {
  // InternalSwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var image4Manifest: Data = Data()

  public var unknownFields = InternalSwiftProtobuf.UnknownStorage()

  /// Metadata about a libCryptex salt. Actual value can be inspected from `SealedHash.Entry.digest`
  public struct Salt: Sendable {
    // InternalSwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = InternalSwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct Proto_SecureConfig: @unchecked Sendable {
  // InternalSwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// NOTE: This field was marked as deprecated in the .proto file.
  public var entry: Data = Data()

  /// NOTE: This field was marked as deprecated in the .proto file.
  public var metadata: Dictionary<String,String> = [:]

  /// contains the full entry data (.metadata + \n + .entry)
  public var data: Data = Data()

  public var unknownFields = InternalSwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_TransparencyProofs: Sendable {
  // InternalSwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var proofs: PrivateCloudCompute_TransparencyLog_ATLogProofs {
    get {return _proofs ?? PrivateCloudCompute_TransparencyLog_ATLogProofs()}
    set {_proofs = newValue}
  }
  /// Returns true if `proofs` has been explicitly set.
  public var hasProofs: Bool {return self._proofs != nil}
  /// Clears the value of `proofs`. Subsequent reads from it will return its default value.
  public mutating func clearProofs() {self._proofs = nil}

  public var unknownFields = InternalSwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _proofs: PrivateCloudCompute_TransparencyLog_ATLogProofs? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_HashAlg: InternalSwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: InternalSwiftProtobuf._NameMap = [
    0: .same(proto: "HASH_ALG_UNKNOWN"),
    1: .same(proto: "HASH_ALG_SHA256"),
    2: .same(proto: "HASH_ALG_SHA384"),
  ]
}

extension Proto_AttestationBundle: InternalSwiftProtobuf.Message, InternalSwiftProtobuf._MessageImplementationBase, InternalSwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AttestationBundle"
  public static let _protobuf_nameMap: InternalSwiftProtobuf._NameMap = [
    1: .standard(proto: "sep_attestation"),
    2: .standard(proto: "ap_ticket"),
    3: .standard(proto: "sealed_hashes"),
    4: .standard(proto: "provisioning_certificate_chain"),
    5: .standard(proto: "app_data"),
    6: .standard(proto: "key_expiration"),
    8: .standard(proto: "transparency_proofs"),
  ]

  fileprivate class _StorageClass {
    var _sepAttestation: Data = Data()
    var _apTicket: Data = Data()
    var _sealedHashes: Proto_SealedHashLedger? = nil
    var _provisioningCertificateChain: [Data] = []
    var _appData: Data = Data()
    var _keyExpiration: InternalSwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _transparencyProofs: Proto_TransparencyProofs? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _sepAttestation = source._sepAttestation
      _apTicket = source._apTicket
      _sealedHashes = source._sealedHashes
      _provisioningCertificateChain = source._provisioningCertificateChain
      _appData = source._appData
      _keyExpiration = source._keyExpiration
      _transparencyProofs = source._transparencyProofs
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: InternalSwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._sepAttestation) }()
        case 2: try { try decoder.decodeSingularBytesField(value: &_storage._apTicket) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._sealedHashes) }()
        case 4: try { try decoder.decodeRepeatedBytesField(value: &_storage._provisioningCertificateChain) }()
        case 5: try { try decoder.decodeSingularBytesField(value: &_storage._appData) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._keyExpiration) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._transparencyProofs) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: InternalSwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._sepAttestation.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._sepAttestation, fieldNumber: 1)
      }
      if !_storage._apTicket.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._apTicket, fieldNumber: 2)
      }
      try { if let v = _storage._sealedHashes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._provisioningCertificateChain.isEmpty {
        try visitor.visitRepeatedBytesField(value: _storage._provisioningCertificateChain, fieldNumber: 4)
      }
      if !_storage._appData.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._appData, fieldNumber: 5)
      }
      try { if let v = _storage._keyExpiration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._transparencyProofs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_AttestationBundle, rhs: Proto_AttestationBundle) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._sepAttestation != rhs_storage._sepAttestation {return false}
        if _storage._apTicket != rhs_storage._apTicket {return false}
        if _storage._sealedHashes != rhs_storage._sealedHashes {return false}
        if _storage._provisioningCertificateChain != rhs_storage._provisioningCertificateChain {return false}
        if _storage._appData != rhs_storage._appData {return false}
        if _storage._keyExpiration != rhs_storage._keyExpiration {return false}
        if _storage._transparencyProofs != rhs_storage._transparencyProofs {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AppData: InternalSwiftProtobuf.Message, InternalSwiftProtobuf._MessageImplementationBase, InternalSwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AppData"
  public static let _protobuf_nameMap: InternalSwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "domain"),
    3: .same(proto: "name"),
    4: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: InternalSwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.version) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.domain) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: InternalSwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.version != 0 {
      try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 1)
    }
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_AppData, rhs: Proto_AppData) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.domain != rhs.domain {return false}
    if lhs.name != rhs.name {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SealedHashLedger: InternalSwiftProtobuf.Message, InternalSwiftProtobuf._MessageImplementationBase, InternalSwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SealedHashLedger"
  public static let _protobuf_nameMap: InternalSwiftProtobuf._NameMap = [
    1: .same(proto: "slots"),
  ]

  public mutating func decodeMessage<D: InternalSwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: InternalSwiftProtobuf._ProtobufMessageMap<InternalSwiftProtobuf.ProtobufString,Proto_SealedHash>.self, value: &self.slots) }()
      default: break
      }
    }
  }

  public func traverse<V: InternalSwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.slots.isEmpty {
      try visitor.visitMapField(fieldType: InternalSwiftProtobuf._ProtobufMessageMap<InternalSwiftProtobuf.ProtobufString,Proto_SealedHash>.self, value: self.slots, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_SealedHashLedger, rhs: Proto_SealedHashLedger) -> Bool {
    if lhs.slots != rhs.slots {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SealedHash: InternalSwiftProtobuf.Message, InternalSwiftProtobuf._MessageImplementationBase, InternalSwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SealedHash"
  public static let _protobuf_nameMap: InternalSwiftProtobuf._NameMap = [
    1: .standard(proto: "hash_alg"),
    2: .same(proto: "entries"),
  ]

  public mutating func decodeMessage<D: InternalSwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.hashAlg) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  public func traverse<V: InternalSwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.hashAlg != .unknown {
      try visitor.visitSingularEnumField(value: self.hashAlg, fieldNumber: 1)
    }
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_SealedHash, rhs: Proto_SealedHash) -> Bool {
    if lhs.hashAlg != rhs.hashAlg {return false}
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SealedHash.Entry: InternalSwiftProtobuf.Message, InternalSwiftProtobuf._MessageImplementationBase, InternalSwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Proto_SealedHash.protoMessageName + ".Entry"
  public static let _protobuf_nameMap: InternalSwiftProtobuf._NameMap = [
    1: .same(proto: "flags"),
    2: .same(proto: "digest"),
    7: .same(proto: "generic"),
    3: .same(proto: "cryptex"),
    4: .standard(proto: "cryptex_salt"),
    5: .standard(proto: "secure_config"),
    6: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: InternalSwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.flags) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.digest) }()
      case 3: try {
        var v: Proto_Cryptex?
        var hadOneofValue = false
        if let current = self.info {
          hadOneofValue = true
          if case .cryptex(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.info = .cryptex(v)
        }
      }()
      case 4: try {
        var v: Proto_Cryptex.Salt?
        var hadOneofValue = false
        if let current = self.info {
          hadOneofValue = true
          if case .cryptexSalt(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.info = .cryptexSalt(v)
        }
      }()
      case 5: try {
        var v: Proto_SecureConfig?
        var hadOneofValue = false
        if let current = self.info {
          hadOneofValue = true
          if case .secureConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.info = .secureConfig(v)
        }
      }()
      case 6: try { try decoder.decodeMapField(fieldType: InternalSwiftProtobuf._ProtobufMap<InternalSwiftProtobuf.ProtobufString,InternalSwiftProtobuf.ProtobufBytes>.self, value: &self.metadata) }()
      case 7: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.info != nil {try decoder.handleConflictingOneOf()}
          self.info = .generic(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: InternalSwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.flags != 0 {
      try visitor.visitSingularInt32Field(value: self.flags, fieldNumber: 1)
    }
    if !self.digest.isEmpty {
      try visitor.visitSingularBytesField(value: self.digest, fieldNumber: 2)
    }
    switch self.info {
    case .cryptex?: try {
      guard case .cryptex(let v)? = self.info else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .cryptexSalt?: try {
      guard case .cryptexSalt(let v)? = self.info else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .secureConfig?: try {
      guard case .secureConfig(let v)? = self.info else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    default: break
    }
    if !self.metadata.isEmpty {
      try visitor.visitMapField(fieldType: InternalSwiftProtobuf._ProtobufMap<InternalSwiftProtobuf.ProtobufString,InternalSwiftProtobuf.ProtobufBytes>.self, value: self.metadata, fieldNumber: 6)
    }
    try { if case .generic(let v)? = self.info {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_SealedHash.Entry, rhs: Proto_SealedHash.Entry) -> Bool {
    if lhs.flags != rhs.flags {return false}
    if lhs.digest != rhs.digest {return false}
    if lhs.info != rhs.info {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SealedHash.Entry.Flags: InternalSwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: InternalSwiftProtobuf._NameMap = [
    0: .same(proto: "FLAG_NONE"),
    2: .same(proto: "FLAG_RATCHET"),
    4: .same(proto: "FLAG_RATCHET_LOCK"),
  ]
}

extension Proto_Cryptex: InternalSwiftProtobuf.Message, InternalSwiftProtobuf._MessageImplementationBase, InternalSwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Cryptex"
  public static let _protobuf_nameMap: InternalSwiftProtobuf._NameMap = [
    1: .standard(proto: "image4_manifest"),
  ]

  public mutating func decodeMessage<D: InternalSwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.image4Manifest) }()
      default: break
      }
    }
  }

  public func traverse<V: InternalSwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.image4Manifest.isEmpty {
      try visitor.visitSingularBytesField(value: self.image4Manifest, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Cryptex, rhs: Proto_Cryptex) -> Bool {
    if lhs.image4Manifest != rhs.image4Manifest {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Cryptex.Salt: InternalSwiftProtobuf.Message, InternalSwiftProtobuf._MessageImplementationBase, InternalSwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Proto_Cryptex.protoMessageName + ".Salt"
  public static let _protobuf_nameMap = InternalSwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: InternalSwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: InternalSwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Cryptex.Salt, rhs: Proto_Cryptex.Salt) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SecureConfig: InternalSwiftProtobuf.Message, InternalSwiftProtobuf._MessageImplementationBase, InternalSwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SecureConfig"
  public static let _protobuf_nameMap: InternalSwiftProtobuf._NameMap = [
    1: .same(proto: "entry"),
    2: .same(proto: "metadata"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: InternalSwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.entry) }()
      case 2: try { try decoder.decodeMapField(fieldType: InternalSwiftProtobuf._ProtobufMap<InternalSwiftProtobuf.ProtobufString,InternalSwiftProtobuf.ProtobufString>.self, value: &self.metadata) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: InternalSwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entry.isEmpty {
      try visitor.visitSingularBytesField(value: self.entry, fieldNumber: 1)
    }
    if !self.metadata.isEmpty {
      try visitor.visitMapField(fieldType: InternalSwiftProtobuf._ProtobufMap<InternalSwiftProtobuf.ProtobufString,InternalSwiftProtobuf.ProtobufString>.self, value: self.metadata, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_SecureConfig, rhs: Proto_SecureConfig) -> Bool {
    if lhs.entry != rhs.entry {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TransparencyProofs: InternalSwiftProtobuf.Message, InternalSwiftProtobuf._MessageImplementationBase, InternalSwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransparencyProofs"
  public static let _protobuf_nameMap: InternalSwiftProtobuf._NameMap = [
    1: .same(proto: "proofs"),
  ]

  public mutating func decodeMessage<D: InternalSwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._proofs) }()
      default: break
      }
    }
  }

  public func traverse<V: InternalSwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._proofs {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_TransparencyProofs, rhs: Proto_TransparencyProofs) -> Bool {
    if lhs._proofs != rhs._proofs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
